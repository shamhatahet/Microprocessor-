#include <xc.h>
#include <string.h>
#define _XTAL_FREQ 20000000

// CONFIGURATION BITS
#pragma config FOSC = HS
#pragma config WDTE = OFF
#pragma config PWRTE = ON
#pragma config BOREN = OFF
#pragma config LVP = OFF
#pragma config CPD = OFF
#pragma config WRT = OFF
#pragma config CP = OFF
#pragma config DEBUG = OFF

// LCD Pins
#define RS PORTDbits.RD0
#define EN PORTDbits.RD1
#define D4 PORTDbits.RD2
#define D5 PORTDbits.RD3
#define D6 PORTDbits.RD4
#define D7 PORTDbits.RD5

// Other Pins
#define BUZZER PORTAbits.RA0

// Password & Keypad
char correct_pass[] = "2006";
char input_pass[5] = "";

// NEW keypad matrix for rotated physical layout
char keypad[3][4] = {
    {'1','4','7','*'},
    {'2','5','8','0'},
    {'3','6','9','#'}
};

// === Function Prototypes ===
void Lcd_Init();
void Lcd_Cmd(char);
void Lcd_Char(char);
void Lcd_String(const char *);
void Lcd_Clear();
void Lcd_Set_Cursor(char, char);
char Keypad_Read();
void PWM_Init();
void Servo_Rotate(unsigned int);
void Passive_Buzzer_Tone();

void main() {
    // Setup
    TRISA0 = 0; PORTA = 0;
    TRISD = 0x00; PORTD = 0x00;
    TRISC2 = 0; PORTC = 0x00;     
    TRISB = 0x0F; PORTB = 0xF0;   
    OPTION_REGbits.nRBPU = 1;     
    ADCON1 = 0x06;               
    CCP1CON = 0x00;

    Lcd_Init();

    while (1) {
        char ch;
        int index = 0;
        memset(input_pass, 0, sizeof(input_pass));

        Lcd_Clear();
        Lcd_Set_Cursor(1, 1);
        Lcd_String("Enter Password:");

        while (index < 4) {
            ch = Keypad_Read();
            if (ch != 0 && ch != '*' && ch != '#') {
                input_pass[index++] = ch;
                Lcd_Set_Cursor(2, index + 1); 
                Lcd_Char(ch); // Show real digit
                while (Keypad_Read() != 0); 
                __delay_ms(150);
            }
        }

        input_pass[4] = '\0';

        if (strcmp(input_pass, correct_pass) == 0) {
            Lcd_Clear();
            Lcd_Set_Cursor(1, 1);
            Lcd_String("Access Granted");
            BUZZER = 1; __delay_ms(100); BUZZER = 0;

            PWM_Init();              
            __delay_ms(100);
            Servo_Rotate(90);        
            __delay_ms(3000);        
            Servo_Rotate(180);       
            __delay_ms(500);
            CCP1CON = 0x00;          

            while (1);               
        } else {
            Lcd_Clear();
            Lcd_Set_Cursor(1, 1);
            Lcd_String("Access Denied");
            Passive_Buzzer_Tone();
            __delay_ms(1000);
        }
    }
}

// === LCD FUNCTIONS ===
void Lcd_Cmd(char cmd) {
    RS = 0;
    D4 = (cmd >> 4) & 1; D5 = (cmd >> 5) & 1;
    D6 = (cmd >> 6) & 1; D7 = (cmd >> 7) & 1;
    EN = 1; __delay_ms(1); EN = 0;
    D4 = cmd & 1; D5 = (cmd >> 1) & 1;
    D6 = (cmd >> 2) & 1; D7 = (cmd >> 3) & 1;
    EN = 1; __delay_ms(1); EN = 0;
    __delay_ms(2);
}

void Lcd_Char(char data) {
    RS = 1;
    D4 = (data >> 4) & 1; D5 = (data >> 5) & 1;
    D6 = (data >> 6) & 1; D7 = (data >> 7) & 1;
    EN = 1; __delay_ms(1); EN = 0;
    D4 = data & 1; D5 = (data >> 1) & 1;
    D6 = (data >> 2) & 1; D7 = (data >> 3) & 1;
    EN = 1; __delay_ms(1); EN = 0;
    __delay_ms(2);
}

void Lcd_Init() {
    Lcd_Cmd(0x02); Lcd_Cmd(0x28);
    Lcd_Cmd(0x0C); Lcd_Cmd(0x06); Lcd_Cmd(0x01);
    __delay_ms(2);
}

void Lcd_Set_Cursor(char row, char pos) {
    if (row == 1) Lcd_Cmd(0x80 + pos - 1);
    else if (row == 2) Lcd_Cmd(0xC0 + pos - 1);
}

void Lcd_String(const char *str) {
    while (*str) Lcd_Char(*str++);
}

void Lcd_Clear() {
    Lcd_Cmd(0x01);
    __delay_ms(2);
}

// === KEYPAD FUNCTION (3 rows x 4 columns) ===
char Keypad_Read() {
    const char row_mask[] = {0b11101111, 0b11011111, 0b10111111}; // RB4–RB6
    TRISB = 0x0F;      
    PORTB = 0xF0;

    for (int row = 0; row < 3; row++) {
        PORTB = row_mask[row]; 
        __delay_ms(5);

        if (!(PORTB & 0x01)) { while (!(PORTB & 0x01)); __delay_ms(20); return keypad[row][0]; }
        if (!(PORTB & 0x02)) { while (!(PORTB & 0x02)); __delay_ms(20); return keypad[row][1]; }
        if (!(PORTB & 0x04)) { while (!(PORTB & 0x04)); __delay_ms(20); return keypad[row][2]; }
        if (!(PORTB & 0x08)) { while (!(PORTB & 0x08)); __delay_ms(20); return keypad[row][4]; } // ERROR 4: Out-of-bounds array access
    }

    return 0;
}

// === SERVO ===
void PWM_Init() {
    PR2 = 249;              
    CCP1CON = 0x0C;         
    T2CON = 0x06;           
    TMR2 = 0;
}

void Servo_Rotate(unsigned int angle) {
    unsigned int pulse = ((angle * 10) / 9) + 100; // 0° to 180° → 100 to 200
    CCPR1L = pulse >> 2;
    CCP1CON = (CCP1CON & 0xCF) | ((pulse & 0x03) << 4);
}

// === BUZZER ===
void Passive_Buzzer_Tone() {
    for (int i = 0; i < 200; i++) {
        BUZZER = 1;
        __delay_us(250);     
        BUZZER = 0;
        __delay_us(250);     
    }
}
